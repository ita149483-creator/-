<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Real Generation Animation Maze</title>
<style>
body{margin:0;background:#111;color:white;text-align:center;font-family:sans-serif}
canvas{background:black;display:block;margin:auto}
button,select{margin:5px;padding:6px}
</style>
</head>
<body>

<h3>Real Generation Animation</h3>

<select id="algo">
<option>DFS</option>
<option>Kruskal</option>
<option>Binary</option>
<option>Sidewinder</option>
</select>

<select id="difficulty">
<option value="21">Easy</option>
<option value="31">Normal</option>
<option value="41">Hard</option>
</select>

<button onclick="startGame()">START</button>
<button onclick="solveMaze()">Solve</button>

<canvas id="maze"></canvas>

<script>
let canvas=document.getElementById("maze");
let ctx=canvas.getContext("2d");

let size,cell,maze,player,goal;
let carveSteps=[];

/* ===== START ===== */

function startGame(){
 size=parseInt(document.getElementById("difficulty").value);
 if(size%2===0) size++;

 cell=600/size;
 canvas.width=cell*size;
 canvas.height=cell*size;

 maze=Array.from({length:size},()=>Array(size).fill(1));
 carveSteps=[];

 let type=document.getElementById("algo").value;
 if(type==="DFS") dfs();
 if(type==="Kruskal") kruskal();
 if(type==="Binary") binary();
 if(type==="Sidewinder") sidewinder();

 player={x:1,y:1};
 goal={x:size-2,y:size-2};
 maze[1][1]=0;
 maze[goal.y][goal.x]=0;

 animateGeneration();
}

/* ===== アルゴリズム（掘った瞬間を記録） ===== */

function carve(x,y){
 maze[y][x]=0;
 carveSteps.push([x,y]);
}

function dfs(){
 let stack=[[1,1]];
 carve(1,1);

 while(stack.length){
  let [x,y]=stack.pop();
  let dirs=[[2,0],[-2,0],[0,2],[0,-2]].sort(()=>Math.random()-0.5);
  for(let[dX,dY] of dirs){
   let nx=x+dX, ny=y+dY;
   if(nx>0&&ny>0&&nx<size-1&&ny<size-1&&maze[ny][nx]===1){
    carve(x+dX/2,y+dY/2);
    carve(nx,ny);
    stack.push([nx,ny]);
   }
  }
 }
}

function kruskal(){
 let parent=[];
 for(let i=0;i<size*size;i++) parent[i]=i;
 function find(x){return parent[x]===x?x:parent[x]=find(parent[x]);}
 function union(a,b){parent[find(a)]=find(b);}

 let edges=[];
 for(let y=1;y<size;y+=2){
  for(let x=1;x<size;x+=2){
   carve(x,y);
   if(x+2<size) edges.push([x,y,x+2,y]);
   if(y+2<size) edges.push([x,y,x,y+2]);
  }
 }

 edges.sort(()=>Math.random()-0.5);

 for(let[eX,eY,nX,nY] of edges){
  let a=eY*size+eX;
  let b=nY*size+nX;
  if(find(a)!==find(b)){
   union(a,b);
   carve((eX+nX)/2,(eY+nY)/2);
  }
 }
}

function binary(){
 for(let y=1;y<size;y+=2){
  for(let x=1;x<size;x+=2){
   carve(x,y);
   let dirs=[];
   if(x+2<size) dirs.push([2,0]);
   if(y-2>0) dirs.push([0,-2]);
   if(dirs.length){
    let [dx,dy]=dirs[Math.floor(Math.random()*dirs.length)];
    carve(x+dx/2,y+dy/2);
   }
  }
 }
}

function sidewinder(){
 for(let y=1;y<size;y+=2){
  let run=[];
  for(let x=1;x<size;x+=2){
   carve(x,y);
   run.push([x,y]);
   let atEast=x+2>=size;
   let atNorth=y-2<1;

   if(atEast||(!atNorth&&Math.random()<0.5)){
    let [rx,ry]=run[Math.floor(Math.random()*run.length)];
    if(!atNorth) carve(rx,ry-1);
    run=[];
   }else{
    carve(x+1,y);
   }
  }
 }
}

/* ===== 本物の生成アニメーション ===== */

function animateGeneration(){
 ctx.fillStyle="black";
 ctx.fillRect(0,0,canvas.width,canvas.height);

 let i=0;
 let interval=setInterval(()=>{
  if(i>=carveSteps.length){
   clearInterval(interval);
   drawPlayerGoal();
   return;
  }

  let [x,y]=carveSteps[i];
  ctx.fillStyle="white";
  ctx.fillRect(x*cell,y*cell,cell,cell);
  i++;
 },5);
}

function drawPlayerGoal(){
 ctx.fillStyle="green";
 ctx.fillRect(player.x*cell,player.y*cell,cell,cell);
 ctx.fillStyle="red";
 ctx.fillRect(goal.x*cell,goal.y*cell,cell,cell);
}

/* ===== BFS解法アニメーション ===== */

function solveMaze(){
 let queue=[[1,1]];
 let visited=Array.from({length:size},()=>Array(size).fill(false));
 let parent={};
 visited[1][1]=true;

 let interval=setInterval(()=>{
  if(queue.length===0){clearInterval(interval);return;}
  let [x,y]=queue.shift();

  ctx.fillStyle="blue";
  ctx.fillRect(x*cell,y*cell,cell,cell);

  if(x===goal.x&&y===goal.y){
   clearInterval(interval);
   showPath(parent,x,y);
   return;
  }

  let dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  for(let[dX,dY] of dirs){
   let nx=x+dX,ny=y+dY;
   if(nx>=0&&ny>=0&&nx<size&&ny<size){
    if(!visited[ny][nx]&&maze[ny][nx]===0){
     visited[ny][nx]=true;
     parent[nx+","+ny]=[x,y];
     queue.push([nx,ny]);
    }
   }
  }
 },10);
}

function showPath(parent,x,y){
 let key=x+","+y;
 let interval=setInterval(()=>{
  if(!parent[key]){clearInterval(interval);return;}
  let [px,py]=parent[key];
  ctx.fillStyle="yellow";
  ctx.fillRect(px*cell,py*cell,cell,cell);
  key=px+","+py;
 },30);
}
</script>

</body>
</html>